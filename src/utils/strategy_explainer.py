import os
import pandas as pd
import numpy as np
import requests
import json
import time

class StrategyExplainer:
    """
    A class to explain strategy comparisons and trading results using LLM.
    """
    def __init__(self, config=None):
        """
        Initialize the StrategyExplainer.

        Args:
            config (dict): Configuration dictionary containing LLM API settings
        """
        self.config = config or {}
        self.api_key = self.config.get('llm_api_key', os.environ.get('LLM_API_KEY', ''))
        self.api_url = self.config.get('llm_api_url', 'https://api.openai.com/v1/chat/completions')
        self.model = self.config.get('llm_model', 'gpt-3.5-turbo')
        self.max_retries = self.config.get('max_retries', 3)
        self.retry_delay = self.config.get('retry_delay', 2)
        
        if not self.api_key:
            print("Warning: No API key provided for LLM. Strategy explanation will use mock data.")
    
    def explain_strategy_comparison(self, comparison_data, strategy_names):
        """
        Generate an explanation of the comparison between different trading strategies.
        
        Args:
            comparison_data (dict): Dictionary containing comparison metrics for each strategy
            strategy_names (dict): Dictionary mapping strategy IDs to display names
            
        Returns:
            str: A detailed explanation of the strategy comparison
        """
        if not self.api_key:
            return self._get_mock_explanation(comparison_data, strategy_names)
        
        # Format the comparison data for the prompt
        formatted_data = self._format_comparison_data(comparison_data, strategy_names)
        
        prompt = f"""
        You are a financial analyst specializing in algorithmic trading strategies. 
        Analyze the following performance metrics for different trading strategies and provide a detailed explanation:

        {formatted_data}

        Please provide:
        1. A summary of how each strategy performed relative to others
        2. Analysis of which strategy performed best in terms of returns, risk-adjusted metrics, and consistency
        3. Explanation of potential reasons for the performance differences
        4. Recommendations for which strategy might be most suitable for different types of investors

        Your explanation should be clear, insightful, and use proper financial terminology.
        """
        
        response = self._query_llm(prompt, max_tokens=800)
        return response.get('explanation', self._get_mock_explanation(comparison_data, strategy_names))
    
    def explain_trading_signals(self, signals_data, strategy_name, price_data=None):
        """
        Generate an explanation of trading signals for a specific strategy.
        
        Args:
            signals_data (pandas.DataFrame): DataFrame containing trading signals
            strategy_name (str): Name of the strategy
            price_data (pandas.DataFrame, optional): Price data corresponding to the signals
            
        Returns:
            str: An explanation of the trading signals
        """
        if not self.api_key:
            return self._get_mock_signal_explanation(strategy_name)
        
        # Format the signals data for the prompt
        signal_summary = self._format_signals_data(signals_data)
        
        # Add price context if available
        price_context = ""
        if price_data is not None:
            price_context = f"""
            Price data summary:
            Starting price: {price_data['Close'].iloc[0]:.2f}
            Ending price: {price_data['Close'].iloc[-1]:.2f}
            Highest price: {price_data['High'].max():.2f}
            Lowest price: {price_data['Low'].min():.2f}
            Overall price change: {((price_data['Close'].iloc[-1] / price_data['Close'].iloc[0]) - 1) * 100:.2f}%
            """
        
        prompt = f"""
        You are a financial analyst specializing in algorithmic trading strategies.
        Analyze the following trading signals generated by the {strategy_name} strategy:

        {signal_summary}
        
        {price_context}

        Please provide:
        1. A summary of the trading activity (frequency of trades, distribution of buy/sell signals)
        2. Analysis of the timing of signals in relation to market conditions
        3. Explanation of what these signals suggest about the strategy's approach
        4. Insights into how this strategy might perform in different market conditions

        Your explanation should be clear, insightful, and use proper financial terminology.
        """
        
        response = self._query_llm(prompt, max_tokens=600)
        return response.get('explanation', self._get_mock_signal_explanation(strategy_name))
    
    def answer_query(self, query, context=None):
        """
        Answer a user query about trading strategies or results.
        
        Args:
            query (str): The user's question
            context (dict, optional): Additional context about strategies and results
            
        Returns:
            str: The answer to the query
        """
        if not self.api_key:
            return self._get_mock_answer(query)
        
        # Format context if available
        context_str = ""
        if context:
            context_str = "Context information:\n"
            for key, value in context.items():
                context_str += f"{key}: {value}\n"
        
        prompt = f"""
        You are a financial advisor and algorithmic trading expert. Answer the following question about trading strategies or results:

        {context_str}
        
        Question: {query}

        Provide a clear, informative answer using proper financial terminology. If the question cannot be answered with the available information, explain what additional information would be needed.
        """
        
        response = self._query_llm(prompt, max_tokens=500)
        return response.get('explanation', self._get_mock_answer(query))
    
    def _format_comparison_data(self, comparison_data, strategy_names):
        """Format comparison data for the prompt."""
        formatted = "Strategy Comparison Metrics:\n"
        
        for strategy_id, metrics in comparison_data.items():
            if strategy_id in strategy_names:
                strategy_display_name = strategy_names[strategy_id]
                formatted += f"\n{strategy_display_name}:\n"
                
                for metric_name, value in metrics.items():
                    if metric_name in ['total_return', 'annualized_return', 'maximum_drawdown', 'win_rate']:
                        formatted += f"- {metric_name.replace('_', ' ').title()}: {value * 100:.2f}%\n"
                    elif metric_name in ['sharpe_ratio', 'sortino_ratio', 'calmar_ratio']:
                        formatted += f"- {metric_name.replace('_', ' ').title()}: {value:.4f}\n"
                    else:
                        formatted += f"- {metric_name.replace('_', ' ').title()}: {value}\n"
        
        return formatted
    
    def _format_signals_data(self, signals_data):
        """Format signals data for the prompt."""
        # Count signal types
        buy_signals = (signals_data > 0).sum().sum()
        sell_signals = (signals_data < 0).sum().sum()
        no_signals = (signals_data == 0).sum().sum()
        
        # Calculate signal transitions
        transitions = 0
        for col in signals_data.columns:
            prev_signal = 0
            for signal in signals_data[col]:
                if signal != prev_signal:
                    transitions += 1
                prev_signal = signal
        
        # Format summary
        summary = f"""
        Signal Summary:
        - Total days analyzed: {len(signals_data)}
        - Buy signals: {buy_signals} ({buy_signals/len(signals_data)*100:.1f}% of days)
        - Sell signals: {sell_signals} ({sell_signals/len(signals_data)*100:.1f}% of days)
        - No position days: {no_signals} ({no_signals/len(signals_data)*100:.1f}% of days)
        - Signal transitions: {transitions} (changes in position)
        """
        
        # Add sample of recent signals
        if len(signals_data) > 0:
            recent_signals = signals_data.tail(10).copy()
            recent_signals_str = "Recent signals (last 10 days):\n"
            
            for idx, row in recent_signals.iterrows():
                signal_type = "Buy" if row.iloc[0] > 0 else "Sell" if row.iloc[0] < 0 else "No Position"
                recent_signals_str += f"- {idx.strftime('%Y-%m-%d') if hasattr(idx, 'strftime') else idx}: {signal_type}\n"
            
            summary += "\n" + recent_signals_str
        
        return summary
    
    def _query_llm(self, prompt, max_tokens=500):
        """
        Query the LLM API with retry logic.
        
        Args:
            prompt (str): The prompt to send to the LLM
            max_tokens (int): Maximum number of tokens in the response
            
        Returns:
            dict: The parsed response from the LLM
        """
        headers = {
            'Content-Type': 'application/json',
            'Authorization': f'Bearer {self.api_key}'
        }
        
        data = {
            'model': self.model,
            'messages': [{'role': 'user', 'content': prompt}],
            'temperature': 0.4,
            'max_tokens': max_tokens
        }
        
        for attempt in range(self.max_retries):
            try:
                response = requests.post(self.api_url, headers=headers, json=data)
                response.raise_for_status()
                
                response_data = response.json()
                content = response_data['choices'][0]['message']['content']
                
                return {'explanation': content}
                
            except requests.exceptions.RequestException as e:
                print(f"API request failed (attempt {attempt+1}/{self.max_retries}): {str(e)}")
                if attempt < self.max_retries - 1:
                    time.sleep(self.retry_delay * (2 ** attempt))  # Exponential backoff
        
        # If all retries fail, return a mock explanation
        return {'explanation': "Unable to generate explanation due to API issues."}
    
    def _get_mock_explanation(self, comparison_data, strategy_names):
        """Generate a mock explanation when API is not available."""
        strategies = list(strategy_names.values())
        
        if not strategies:
            return "No strategies were compared. Please run a backtest with multiple strategies to see a comparison."
        
        # Find best strategy based on total return if available
        best_strategy = strategies[0]
        if comparison_data:
            best_return = -float('inf')
            for strategy_id, metrics in comparison_data.items():
                if strategy_id in strategy_names and 'total_return' in metrics:
                    if metrics['total_return'] > best_return:
                        best_return = metrics['total_return']
                        best_strategy = strategy_names[strategy_id]
        
        explanation = f"""
        # Strategy Comparison Analysis
        
        I've analyzed the performance of the following strategies: {', '.join(strategies)}.
        
        ## Performance Summary
        Based on the backtest results, {best_strategy} appears to be the strongest performer in terms of overall returns. 
        Each strategy has its own strengths and weaknesses:
        
        - Moving average strategies tend to perform well in trending markets but may generate false signals during sideways markets.
        - RSI-based strategies excel at identifying overbought and oversold conditions, making them suitable for range-bound markets.
        - Machine learning strategies can adapt to complex patterns but may be prone to overfitting on historical data.
        - Sentiment-based strategies incorporate market psychology, potentially capturing information not reflected in price action alone.
        
        ## Risk-Adjusted Performance
        When considering risk-adjusted metrics like Sharpe ratio, strategies that maintain consistent returns with lower volatility often outperform those with higher but more volatile returns.
        
        ## Recommendation
        For conservative investors, strategies with higher Sharpe ratios and lower drawdowns would be more suitable.
        For aggressive investors seeking higher returns, strategies with the highest total return might be preferred despite potentially higher volatility.
        
        Consider combining multiple strategies for a more robust approach that can perform well across different market conditions.
        """
        
        return explanation
    
    def _get_mock_signal_explanation(self, strategy_name):
        """Generate a mock signal explanation when API is not available."""
        return f"""
        # Trading Signal Analysis for {strategy_name}
        
        The {strategy_name} generated a balanced mix of buy and sell signals throughout the testing period. 
        
        ## Signal Distribution
        The strategy showed a tendency to maintain positions for several days before switching, indicating it's designed to capture medium-term trends rather than short-term fluctuations.
        
        ## Market Adaptation
        The signals appear to align with major market movements, with buy signals generally occurring during uptrends and sell signals during downtrends.
        
        ## Strategy Characteristics
        This pattern of signals suggests that {strategy_name} is designed to:
        - Identify trend reversals
        - Filter out market noise
        - Maintain positions through minor fluctuations
        
        ## Potential Performance
        This strategy would likely perform best in markets with clear directional trends and might struggle during highly volatile or sideways markets with no clear direction.
        """
    
    def _get_mock_answer(self, query):
        """Generate a mock answer when API is not available."""
        query_lower = query.lower()
        
        if "best strategy" in query_lower or "which strategy" in query_lower:
            return "The best strategy depends on your investment goals, risk tolerance, and market conditions. Moving average strategies work well in trending markets, while RSI strategies perform better in range-bound markets. Machine learning strategies can adapt to complex patterns but require proper validation to avoid overfitting."
        
        elif "how" in query_lower and "work" in query_lower:
            return "This algorithmic trading system works by analyzing historical price data, applying technical indicators or machine learning models to identify patterns, and generating buy/sell signals based on predefined rules or learned patterns. The system then simulates trading based on these signals and calculates performance metrics to evaluate strategy effectiveness."
        
        elif "risk" in query_lower:
            return "Risk management is implemented through position sizing, stop-loss orders, and diversification across multiple strategies. The system calculates risk-adjusted metrics like Sharpe ratio, maximum drawdown, and win rate to help evaluate the risk-return profile of each strategy."
        
        else:
            return "I don't have specific information to answer that question with the current context. To provide a more accurate answer, I would need additional details about the strategies, backtest parameters, or specific metrics you're interested in."